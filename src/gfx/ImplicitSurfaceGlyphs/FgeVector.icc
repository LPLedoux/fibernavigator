///////////////////////////////////////////////////////////////////////////////
//                                                                           
///// /////  ////       Project  :   FAnToM                    
//   //  // //  //      Module   :   Fge (Rendering and Viewer Components)
//   //  // /////       File     :   $RCSfile: FgeVector.icc,v $
//   //  // //          Language :   C++
//    /////  ////       Date     :   $Date: 2002/11/19 20:20:52 $
         //             Author   :   $Author: hergen $
//////////              Revision :   $Revision: 1.6 $ 



#ifndef __FGE_VECTOR_ICC__
#define __FGE_VECTOR_ICC__



#include <math.h>



void FgeVector::set(GLdouble elem_x, 
                    GLdouble elem_y, 
                    GLdouble elem_z) {
  data[0] = elem_x;
  data[1] = elem_y;
  data[2] = elem_z;
}
GLdouble FgeVector::getX(void) const {
  return(data[0]);
}
GLdouble FgeVector::getY(void) const {
  return(data[1]);
}
GLdouble FgeVector::getZ(void) const {
  return(data[2]);
}


FgeVector FgeVector::operator-(void) const {
  FgeVector result;

  result.data[0] = -data[0];
  result.data[1] = -data[1];
  result.data[2] = -data[2];

  return(result);
}


void FgeVector::operator+=(const FgeVector& vector) {
  data[0] += vector.data[0];
  data[1] += vector.data[1];
  data[2] += vector.data[2];
}


FgeVector FgeVector::operator+(const FgeVector& vector) const {
  FgeVector result;

  result.data[0] = data[0] + vector.data[0];
  result.data[1] = data[1] + vector.data[1];
  result.data[2] = data[2] + vector.data[2];

  return(result);
}


void FgeVector::operator-=(const FgeVector& vector) {
  data[0] -= vector.data[0];
  data[1] -= vector.data[1];
  data[2] -= vector.data[2];
}


FgeVector FgeVector::operator-(const FgeVector& vector) const {
  FgeVector result;

  result.data[0] = data[0] - vector.data[0];
  result.data[1] = data[1] - vector.data[1];
  result.data[2] = data[2] - vector.data[2];

  return(result);
}


void FgeVector::operator*=(GLdouble s) {
  data[0] *= s;
  data[1] *= s;
  data[2] *= s;
}


FgeVector FgeVector::operator*(GLdouble s) const {
  FgeVector result;

  result.data[0] = s * data[0];
  result.data[1] = s * data[1];
  result.data[2] = s * data[2];

  return(result);
}


GLdouble FgeVector::operator*(const FgeVector& vector) const {

  return(data[0]*vector.data[0] + data[1]*vector.data[1] + data[2]*vector.data[2]);

}


FgeVector FgeVector::operator^(const FgeVector& vector) const {
  FgeVector result;

  result.data[0] = data[1]*vector.data[2] - data[2]*vector.data[1]; 
  result.data[1] = data[2]*vector.data[0] - data[0]*vector.data[2];
  result.data[2] = data[0]*vector.data[1] - data[1]*vector.data[0];

  return(result);
}


GLdouble FgeVector::len(void) const {
  return(sqrt( lenSquare() ));
}

GLdouble FgeVector::lenSquare( void ) const {
  return (data[0]*data[0] + data[1]*data[1] + data[2]*data[2]);
}


void FgeVector::normalize(void) {
  GLdouble length;

  length = len();
  data[0] /= length;
  data[1] /= length;
  data[2] /= length;
}


FgeVector FgeVector::findNormal(void) const {
  FgeVector v(data[0], data[1], data[2]);   // don't want to toast ourselves...
  FgeVector uv1(1.0, 0.0, 0.0);
  FgeVector uv2(0.0, 1.0, 0.0);
  FgeVector p, s, n;

  v.normalize();
          // div bdata[1] 0 edata[0]ception will be caught

  // we're now going to project two different coordinate sdata[1]stem base
  // vectors to the plane given bdata[1] the origin and the vector v
  p = uv1 - v * (v * uv1);
  s = uv2 - v * (v * uv2);

  // interpret p, s as normals to v and choose the longest
  if(p.len() > s.len()) n = p;
  else                  n = s;

  n.normalize();

  return(n);
}



#endif   // __FGE_VECTOR_ICC__
