//Copyright (c) 2008 Aaron Knoll, Younis Hijazi, Andrew Kensler, Mathias Schott, Charles Hansen and Hans Hagen
//
// edited 2009 by Mario Hlawitschka and Alexander Wiebel
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.
#include "iarith.cg"

//reduced affine form
typedef float4 raf;

//raf.x = central value;
//raf.y = e1 (shared symbol)
//raf.z = e2 (shared symbol)
//raf.w = e3 (condensation symbol)

//General idea: share e1 and e2 between affine terms, generate & condense e3.

raf make_raf(float lo, float hi)
{
  raf r;
  r.x = (hi + lo);
  r.y = (hi - lo);
  r.xy *= .5;
  r.zw = 0;
  return r;
}

raf interval_to_raf(interval i)
{
  raf r;
  r.x = (i.y + i.x);
  r.y = (i.y - i.x);
  r.xy *= .5;
  r.zw = 0;
  return r;
}

float raf_radius(raf r)
{
  const float4 ae = abs(r);
  return ae.y + ae.z + ae.w;

  //return r.y + r.z + r.w;
}

interval raf_to_interval(raf r)
{
  const float rad = raf_radius(r);
  return interval(r.x - rad, r.x + rad);
}

bool raf_contains(raf r, float f)
{
  const float rad = raf_radius(r);
  return (f >= (r.x - rad) && f <= (r.x + rad));
}

raf raf_add(raf a, float b)
{
  raf r = a;
  r.x += b;
  return r;
}

raf raf_add(float a, raf b)
{
  raf r = b;
  r.x += a;
  return r;
}

raf raf_add(raf a, raf b)
{
  return a + b;
}

raf raf_sub(raf a, float b)
{
  raf r = a;
  r.x -= b;
  return r;
}

raf raf_sub(float a, raf b)
{
  raf r = b;
  r.x = a - b.x;
  return r;
}

raf raf_sub(raf a, raf b)
{
  return a - b;

  //AARONBAD -- this isn't the official definition, but it works. Why?!!!  
  //raf r;
  //r.x = a.x - b.x;
  //r.yzw = a.yzw + b.yzw;
  //return r;
}

raf raf_abs(raf r)
{
  interval i = raf_to_interval(r);
  
  if (i.x > 0) //strictly positive
    return r;
    
  if (i.y < 0)  //strictly negative
    return -r;

  raf t = r * .5;
  t.x = abs(t.x);
  return t;
}

raf raf_neg(raf r)
{
  return -r;
}

raf raf_rcp(float inf, raf a)
{
  interval i = raf_to_interval(a);
  const bool ic0 = (i.x <= 0 && i.y >= 0);
  
  raf r;
  if (ic0)
  {
    r.y = inf;
    return r;
  }
  
  const float2 iabs = abs(i);
  const float2 sia = sqrt(iabs);
  
  const float t = sia.x + sia.y;
  const float alpha = 1/t;
  const float dzeta = (t*.125) + (.5*sia.x*sia.y*alpha);
  
  const float rdelta = sia.y - sia.x;
  const float delta = rdelta*rdelta*.125*alpha;
  
  //make the affine form
  r = alpha * a;
  r.x += dzeta;
  
  //condense error term delta into w
  r.w = abs(r.w) + delta;   //note delta is always positive

  return r;
}

raf raf_mul(raf a, float b)
{
  return a*b;
}

raf raf_mul(float a, raf b)
{
  return a*b;
}

raf raf_mul(raf a, raf b)
{
  raf r;
  r.x = a.x * b.x;
  r.yzw = a.xxx*b.yzw + b.xxx*a.yzw;
  const float cs = raf_radius(a) * raf_radius(b);
  if (r.z || r.w)
    r.w = abs(r.w) + cs;
  else
    r.z = cs;
  
  return r;
}

raf raf_div(float inf, raf a, float b)
{
  return raf_mul(a, 1/b);
}

raf raf_div(float inf, float a, raf b)
{
  return raf_mul(a, raf_rcp(inf, b));
}

raf raf_div(float inf, raf a, raf b)
{
  return raf_mul(a, raf_rcp(inf, b));
}

raf raf_sqr(raf a)
{
  return raf_mul(a,a);  //is this any good? This is what libaffa does...
}


/*
//AARONBAD - TODO

interval iexp(interval i)
{
	return exp(i);
}

interval ilog(float nan, float inf, interval i)
{
	interval r;
	r.x = i.x < 0 ? -inf : log(i.x);
	r.y = log(i.y);
	r.x = i.y < 0 ? nan : r.x;
	r.y = i.y < 0 ? nan : r.y;
	return r;
}

interval iln(float nan, float inf, interval i)
{
	return ilog(nan, inf, i);
}

interval ipow(float nan, float inf, interval i, float p)
{
	return iexp(imul(p, ilog(nan, inf, i)));
}

interval ipow(float nan, float inf, interval i, interval p)
{
	return iexp(imul(p, ilog(nan, inf, i)));
}

interval isqrt(float nan, float inf, interval i)
{
	return ipow(nan, inf, i, .5);
}

interval icos(interval i)
{
	float divtest = abs(i.x) / (2*PI);
	float ip = divtest - frac(divtest);
	interval imv = i + (i.x < 0 ? 2*PI*(ip+1) : -2*PI*ip);
	interval cosine = cos(imv);
    interval result;
	result.x = min(cosine.x, cosine.y);
	result.y = max(cosine.x, cosine.y);
	result.x = (icontains(imv, PI) || imv.y >= 3*PI) ? -1 : result.x;
	result.y = (imv.y >= 2*PI) ? 1 : result.y;
	return result;
}

interval isin(interval i)
{
	return icos(isub(i,.5*PI));
}

interval itan(float inf, interval i)
{
	return idiv(inf, isin(i), icos(i));
}

*/
