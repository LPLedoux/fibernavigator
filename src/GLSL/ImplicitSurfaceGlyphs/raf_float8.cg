//Copyright (c) 2008 Aaron Knoll, Younis Hijazi, Andrew Kensler, Mathias Schott, Charles Hansen and Hans Hagen
//
// edited 2009 by Mario Hlawitschka and Alexander Wiebel
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.
#include "iarith.cg"

//reduced affine form
struct raf
{
  float4 x1;
  float4 x2;
  int l;
};

//x1.x = central value;
//x1.y = e1 (shared symbol)
//x1.z = e2 (shared symbol)
//x1.w = e3 (shared symbol)

//x4.x = e4 (shared symbol)
//x4.y = e5 (shared symbol)
//x4.z = e6 (shared symbol)
//x4.w = e7 (condensation symbol)

raf make_raf(float lo, float hi)
{
  raf r;
  r.x1.x = (hi + lo);
  r.x1.y = (hi - lo);
  r.x1.xy *= .5;
  r.x1.zw = 0;
  r.x2 = 0;  
  return r;
}

raf interval_to_raf(interval i)
{
  raf r;
  r.x1.x = (i.y + i.x);
  r.x1.y = (i.y - i.x);
  r.x1.xy *= .5;
  r.x1.zw = 0;
  r.x2 = 0;  
  return r;
}

float raf_radius(raf r)
{
  const float4 ae1 = abs(r.x1);
  const float4 ae2 = abs(r.x2);
  return ae1.y + ae1.z + ae1.w + ae2.x + ae2.y + ae2.z + ae2.w;
}

interval raf_to_interval(raf r)
{
  const float rad = raf_radius(r);
  return interval(r.x1.x - rad, r.x1.x + rad);
}

bool raf_contains(raf r, float f)
{
  const float rad = raf_radius(r);
  return (f >= (r.x1.x - rad) && f <= (r.x1.x + rad));
}

raf raf_add(raf a, float b)
{
  raf r;
  r.x1 = a.x1;
  r.x2 = a.x2;
  r.x1.x += b;
  return r;
}

raf raf_add(float a, raf b)
{
  raf r;
  r.x1 = b.x1;
  r.x2 = b.x2;
  r.x1.x += a;
  return r;
}

raf raf_add(raf a, raf b)
{
  raf r;
  r.x1 = a.x1 + b.x1;
  r.x2 = a.x2 + b.x2;
  return r;
}

raf raf_sub(raf a, float b)
{
  raf r;
  r.x1 = a.x1;
  r.x1.x -= b;
  r.x2 = a.x2;
  return r;
}

raf raf_sub(float a, raf b)
{
  raf r;
  r.x1 = -b.x1;
  r.x1.x += a;
  r.x2 = -b.x2;
  return r;
}

raf raf_sub(raf a, raf b)
{
  raf r;
  r.x1 = a.x1 - b.x1;
  r.x2 = a.x2 - b.x2;
  return r;
}

raf raf_abs(raf r)
{
  interval i = raf_to_interval(r);
  
  if (i.x > 0) //strictly positive
    return r;
    
  if (i.y < 0)  //strictly negative
    return raf_neg(r);

  raf t = raf_mul(r,.5);
  t.x1.x = abs(t.x1.x);
  return t;
}

raf raf_neg(raf a)
{
  raf r;
  r.x1 = -a.x1;
  r.x2 = -a.x2;
  return r;
}

raf raf_rcp(float inf, raf a)
{
  interval i = raf_to_interval(a);
  const bool ic0 = (i.x <= 0 && i.y >= 0);
  
  raf r;
  if (ic0)
  {
    r.x1.y = inf;
    return r;
  }
  
  const float2 iabs = abs(i);
  const float2 sia = sqrt(iabs);
  
  const float t = sia.x + sia.y;
  const float alpha = 1/t;
  const float dzeta = (t*.125) + (.5*sia.x*sia.y*alpha);
  
  const float rdelta = sia.y - sia.x;
  const float delta = rdelta*rdelta*.125*alpha;
  
  //make the affine form
  r = raf_mul(a, alpha);
  r.x1.x += dzeta;
  
  //condense error term delta into w
  r.x1.z = abs(r.x1.z) + delta;   //note delta is always positive
  r.x2 = 0;
  
  return r;
}

raf raf_mul(raf a, float b)
{
  raf r;
  r.x1 = a.x1 * b;
  r.x2 = a.x2 * b;
  return r;
}

raf raf_mul(float a, raf b)
{
  raf r;
  r.x1 = b.x1 * a;
  r.x2 = b.x2 * a;
  return r;
}

raf raf_mul(raf a, raf b)
{
  raf r;
  r.x1.x = a.x1.x * b.x1.x;
  r.x1.yzw = a.x1.xxx*b.x1.yzw + b.x1.xxx*a.x1.yzw;
  r.x2 = a.x1.xxxx * b.x2.xyzw + b.x1.xxxx * a.x2.xyzw;
  const float cs = raf_radius(a) * raf_radius(b);

  if (!r.x1.z)
    r.x1.z = cs;
  else if (!r.x1.w)
    r.x1.w = cs;
  else if (!r.x2.x)
    r.x2.x = cs;
  else if (!r.x2.y)
    r.x2.y = cs;
  else if (!r.x2.z)
    r.x2.z = cs;
  //else if (!r.x2.w)
  //  r.x2.w = cs;
  else
    r.x2.w = abs(r.x2.w) + cs;
  return r;
}

raf raf_div(float inf, raf a, float b)
{
  return raf_mul(a, 1/b);
}

raf raf_div(float inf, float a, raf b)
{
  return raf_mul(a, raf_rcp(inf, b));
}

raf raf_div(float inf, raf a, raf b)
{
  return raf_mul(a, raf_rcp(inf, b));
}

raf raf_sqr(raf a)
{
  return raf_mul(a,a);  //is this any good? This is what libaffa does...
}


/*
//AARONBAD - TODO

interval iexp(interval i)
{
	return exp(i);
}

interval ilog(float nan, float inf, interval i)
{
	interval r;
	r.x = i.x < 0 ? -inf : log(i.x);
	r.y = log(i.y);
	r.x = i.y < 0 ? nan : r.x;
	r.y = i.y < 0 ? nan : r.y;
	return r;
}

interval iln(float nan, float inf, interval i)
{
	return ilog(nan, inf, i);
}

interval ipow(float nan, float inf, interval i, float p)
{
	return iexp(imul(p, ilog(nan, inf, i)));
}

interval ipow(float nan, float inf, interval i, interval p)
{
	return iexp(imul(p, ilog(nan, inf, i)));
}

interval isqrt(float nan, float inf, interval i)
{
	return ipow(nan, inf, i, .5);
}

interval icos(interval i)
{
	float divtest = abs(i.x) / (2*PI);
	float ip = divtest - frac(divtest);
	interval imv = i + (i.x < 0 ? 2*PI*(ip+1) : -2*PI*ip);
	interval cosine = cos(imv);
    interval result;
	result.x = min(cosine.x, cosine.y);
	result.y = max(cosine.x, cosine.y);
	result.x = (icontains(imv, PI) || imv.y >= 3*PI) ? -1 : result.x;
	result.y = (imv.y >= 2*PI) ? 1 : result.y;
	return result;
}

interval isin(interval i)
{
	return icos(isub(i,.5*PI));
}

interval itan(float inf, interval i)
{
	return idiv(inf, isin(i), icos(i));
}

*/
