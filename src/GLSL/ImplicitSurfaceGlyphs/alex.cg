//Copyright (c) 2008 Aaron Knoll, Younis Hijazi, Andrew Kensler, Mathias Schott, Charles Hansen and Hans Hagen
//
// edited 2009 by Mario Hlawitschka and Alexander Wiebel
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.

samplerCUBE cube_map;
sampler1D hsv_colors;
sampler1D permutations_x_tex;
sampler1D permutations_y_tex;
sampler1D permutations_z_tex;
sampler1D vectors_xyz_tex;

sampler2D mydata;

float glyphId;

#define PTS 0
#if PTS
float pts[4][4][4];
#endif

STUB__ARITHMETIC_INCLUDE

GEN__IA

STUB__EVALUATE

struct app_vertex
{
    float4 Position     : POSITION;
    float4 TexCoord     : TEXCOORD7; 
    float4 Color	: COLOR0;
    float4 TexCoord3    : TEXCOORD3;
};

struct vertex_fragment
{
    float4 Position	  : POSITION; // For the rasterizer
    float4 TexCoord	  : TEXCOORD7; 
    float4 Color	  : TEXCOORD1;
//     float4 ScreenPos      : TEXCOORD2;
    float4 GlyphPosition  : TEXCOORD3;
};

struct fragment_out 
{
    float4 Color	: COLOR0;
    float depth         : DEPTH;
};

// Raycasting vertex program implementation
vertex_fragment vertex_main( app_vertex IN )
{    
    vertex_fragment OUT;
    
    // Get OpenGL state matrices
    float4x4 ModelView = glstate.matrix.modelview[0];
    float4x4 ModelViewProj = glstate.matrix.mvp;
    
    // Transform vertex
    OUT.Position = mul( ModelViewProj, IN.Position );
//alex changed this to be ModelView only? egal ..... wird momentan sowieso nirgends benutzt
//    OUT.ScreenPos =  mul( ModelView, IN.Position );	//this gives us the SCREEN SPACE position of the pixel
    
    OUT.TexCoord = IN.TexCoord;													
    OUT.Color = IN.Color;
    OUT.GlyphPosition = IN.TexCoord3;
    return OUT;
}

float tc(float idx)
{
    return (idx/256);
}

float4 tc(float4 idx)
{
    return (idx/256);
}


float perlin3d(float3 p)
{
    float3 integer = floor(p);
    float3 fraction = p - integer;
    float3 fade = ((6 * fraction - float3(15,15,15)) * fraction + float3(10,10,10)) * fraction * fraction * fraction;
    float3 one_minus_fade = float3(1,1,1) - fade;
    
    float4 hash_y;
    hash_y.xy = tex1D(permutations_x_tex, tc(integer.x)).x;
    hash_y.zw = tex1D(permutations_x_tex, tc(integer.x+1)).x;
    
//#define KKS_HASH
#ifdef KKS_HASH
    //Kensler, Knoll & Shirley 08 xor hash
    int4 iy = (int4)integer.yyyy;
    iy.yw += 1;
    hash_y = (float4)((int4)(hash_y) ^ iy);
#else
    hash_y += integer.yyyy;
    hash_y.yw += 1;
#endif
    hash_y = tc(hash_y);
    hash_y.x = tex1D(permutations_y_tex, hash_y.x).x;
    hash_y.y = tex1D(permutations_y_tex, hash_y.y).x;
    hash_y.z = tex1D(permutations_y_tex, hash_y.z).x;
    hash_y.w = tex1D(permutations_y_tex, hash_y.w).x;
    
    float4 hash_z0, hash_z1;
#ifdef KKS_HASH
    hash_z0 = (float4)(((int4)hash_y) ^ ((int4)integer.zzzz));
    hash_z1 = (float4)(((int4)hash_y) ^ ((int4)integer.zzzz + int4(1,1,1,1)));
#else
    hash_z0 = hash_y + integer.zzzz;
    hash_z1 = hash_z0 + float4(1,1,1,1);
#endif
    hash_z0 = tc(hash_z0);
    hash_z1 = tc(hash_z1);
    
    hash_z0.x = tex1D(permutations_z_tex, hash_z0.x).x;
    hash_z0.y = tex1D(permutations_z_tex, hash_z0.y).x;
    hash_z0.z = tex1D(permutations_z_tex, hash_z0.z).x;
    hash_z0.w = tex1D(permutations_z_tex, hash_z0.w).x;
    hash_z1.x = tex1D(permutations_z_tex, hash_z1.x).x;
    hash_z1.y = tex1D(permutations_z_tex, hash_z1.y).x;
    hash_z1.z = tex1D(permutations_z_tex, hash_z1.z).x;
    hash_z1.w = tex1D(permutations_z_tex, hash_z1.w).x;
    
    hash_z0 = tc(hash_z0);
    hash_z1 = tc(hash_z1);
    
    float4 vectors_x_z0, vectors_y_z0, vectors_z_z0,
        vectors_x_z1, vectors_y_z1, vectors_z_z1;
    
    {
	float3 vxyz = tex1D(vectors_xyz_tex, hash_z0.x).xyz;
        vectors_x_z0.x = vxyz.x;
        vectors_y_z0.x = vxyz.y;
        vectors_z_z0.x = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z0.y).xyz;
        vectors_x_z0.y = vxyz.x;
        vectors_y_z0.y = vxyz.y;
        vectors_z_z0.y = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z0.z).xyz;
        vectors_x_z0.z = vxyz.x;
        vectors_y_z0.z = vxyz.y;
        vectors_z_z0.z = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z0.w).xyz;
        vectors_x_z0.w = vxyz.x;
        vectors_y_z0.w = vxyz.y;
        vectors_z_z0.w = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z1.x).xyz;
        vectors_x_z1.x = vxyz.x;
        vectors_y_z1.x = vxyz.y;
        vectors_z_z1.x = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z1.y).xyz;
        vectors_x_z1.y = vxyz.x;
        vectors_y_z1.y = vxyz.y;
        vectors_z_z1.y = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z1.z).xyz;
        vectors_x_z1.z = vxyz.x;
        vectors_y_z1.z = vxyz.y;
        vectors_z_z1.z = vxyz.z;
    }
    {
        float3 vxyz = tex1D(vectors_xyz_tex, hash_z1.w).xyz;
        vectors_x_z1.w = vxyz.x;
        vectors_y_z1.w = vxyz.y;
        vectors_z_z1.w = vxyz.z;
    }
    
    float4 fx;
    fx.xyzw = fraction.x;
    fx.zw -= 1;
    float4 fy;
    fy.xyzw = fraction.y;
    fy.yw -= 1;
    
    float4 dots_z0 = fx * vectors_x_z0 + fy * vectors_y_z0 + fraction.z * vectors_z_z0;
    float4 dots_z1 = fx * vectors_x_z1 + fy * vectors_y_z1 + (fraction.z-float4(1,1,1,1)) * vectors_z_z1;
    float4 value4 = one_minus_fade.zzzz * dots_z0 + fade.zzzz * dots_z1;
    float2 value2 = one_minus_fade.yy * value4.xz + fade.yy * value4.yw;
    
    return (one_minus_fade.x * value2.x + fade.x * value2.y);
}

float turbulence(int octaves, float3 p, float lacunarity, float gain)
{
  float sum = 0;
  float scale = 1;
  float total_gain = 1;
  for(int i=0; i<octaves; i++)
  {
    sum += total_gain * perlin3d(p*scale);
    scale *= lacunarity;
    total_gain *= gain;
  }
  return sum;
}

bool depth_peel_allow(float t1, float t0, float3 orig, float3 dir, float w, float r0, float r1, float r2)
{
  const float3 p0 = orig + (dir*t0);
	const float3 g0 = evaluate_gradient(p0, w, r0, r1, r2);

  const float3 p1 = orig + (dir*t1);
	const float3 g1 = evaluate_gradient(p1, w, r0, r1, r2);

  return (dot(dir, g0) * dot(dir, g1) < 0);
}

struct hitrecord
{
  float4 thit;
  float4 opt;
};

hitrecord traverse(float3 orig, float3 dir, float w, float r0, float r1, float r2, float4 isovalue, float iso_incr, float inf, float nan, float max_depth, float epsilon, float delta)
{
    hitrecord hr;
    
    hr.thit = -1;
    
    interval t = interval(0,1);
    
    //interval ix, iy, iz;
    //interval F_t;
  STUB__TINTERVAL_SETUP
      
	//t = interval(0,1);
  
  //ix = iadd(orig.x, imul(t, dir.x));
  //iy = iadd(orig.y, imul(t, dir.y));
  //iz = iadd(orig.z, imul(t, dir.z));
  //F_t = evaluate_interval(nan, inf, ix, iy, iz, w, r0, r1, r2); 
  //if (icontains(F_t, 0))
  STUB__TINTERVAL_COMPUTE_AND_TEST
  {
      int d=0;
      float tincr = .5f;
      const int dlast = min(max_depth-1, log2(length(dir)/epsilon));
      
      t.x = 0;
      for(int i=0; i<1000; i++)
      {
          bool skip=false;
          t.y = t.x + tincr;
          
          //ix = iadd(orig.x, imul(t, dir.x));
          //iy = iadd(orig.y, imul(t, dir.y));
          //iz = iadd(orig.z, imul(t, dir.z));
          //F_t = evaluate_interval(nan, inf, ix, iy, iz, w, r0, r1, r2);
          //if (icontains(F_t, 0))
          STUB__TINTERVAL_COMPUTE_AND_TEST
          {
              STUB__TERMINATE_CONDITION
                  //if (d==dlast)
              {
                  STUB__HIT          
                      }
              else
              {
                  tincr *= .5f;
                  d++;
                  skip=true;
              }
          }
          if(!skip)
          {
              t.x = t.y;
              
              float tincr_next, fp;	
              tincr_next = 2.f * tincr;
              fp = frac(t.x/tincr_next);
              if (fp < 1e-8)		//if fp == 0
              {
                  for(int j=0; j<24; j++)
                  {
                      tincr = tincr_next;
                      d--;
                      tincr_next = tincr * 2.f;
                      fp = frac(t.x/tincr_next);
                      if (d == -1 || fp > 1e-8) break;		//if d == -1 || fp != 0
                  }
                  if (d == -1)
                      break;
              }
          }
      }
  }
  return hr;
}

#define METAL 0
#if METAL

float4 shade(float thit, float opt, 
             float3 domain_min,
             float3 domain_max,
            float3 orig, float3 dir, float3 ray_dir, 
            float inf, float nan, float w, float r0, float r1, float r2, float4 isovalue, float iso_incr, 
            float bumpmap_frequency, float shadow_eps_factor, float max_depth, float epsilon, float delta, float dp_alpha,
            float phong_exponent, float3 light_pos, float3 front_color, float3 back_color, float4 domain_color,
            float iso_color_offset, float iso_color_scale, float4 INTexCoord)
{

  //shade
  float3 phit = orig + (dir*thit);
 
  float4 color = float3(0,0,0,1);
  float3 totalReflectivity = float3(1,1,1);
  //totalReflectivity *= .25;

  //const float3 metalReflectColor = float3(.2, .6, .9);  
  const float3 metalReflectColor = float3(.75, .75, .80); 

  float3 normal;
  
  float3 reflect_dir = dir;

#define MAX_BOUNCE 4

  for(int b=1; b<=MAX_BOUNCE; b++)
  {
    STUB__EVAL_GRADIENT
    normal = normalize(gradient);

    float3 v = -normalize(reflect_dir);
    float n_dot_v = dot(normal, v);
    if(n_dot_v < 0)
      normal = -normal;
    
    float3 reflect_org;
    {
      float3 reflect_ray_dir = v + 2 * n_dot_v * normal;
      const float3 reflect_domain_t0 = (domain_min - phit) / reflect_ray_dir;
      const float3 reflect_domain_t1 = (domain_max - phit) / reflect_ray_dir;
      const float3 reflect_tmax = max(reflect_domain_t0, reflect_domain_t1);   
      const float reflect_texit = min(reflect_tmax.x, min(reflect_tmax.y, reflect_tmax.z));
      const float3 reflect_pexit = phit + (reflect_texit * reflect_ray_dir);

      //const float reflect_eps = shadow_eps_factor*max(pow(.5, max_depth), epsilon);
      reflect_dir = reflect_pexit - phit;
      reflect_org = phit;
    }
    hitrecord reflect_hr = traverse(reflect_org, reflect_dir, w, r0, r1, r2, isovalue, iso_incr, inf, nan, max_depth, epsilon, delta);

    totalReflectivity *= saturate(metalReflectColor + (float3(1,1,1)-metalReflectColor)*pow((1-n_dot_v), 5));
    if (reflect_hr.thit.x < 0 || b==MAX_BOUNCE)
      break;
    phit = reflect_org + (reflect_dir * reflect_hr.thit.x);
  }  
  
STUB__CUBEMAP_IFDEF
  color = totalReflectivity * texCUBE(cube_map,reflect(-reflect_dir, normal)).xyz;
#else
  color = totalReflectivity * domain_color;
#endif

  return color;
}

#else
float3 shade(float thit, float opt, float3 domain_min, float3 domain_max, 
            float3 orig, float3 dir, float3 ray_dir, 
            float inf, float nan, float w, float r0, float r1, float r2, float4 isovalue, float iso_incr, 
            float bumpmap_frequency, float shadow_eps_factor, float max_depth, float epsilon, float delta, float dp_alpha,
            float phong_exponent, float3 light_pos, float3 front_color, float3 back_color, float3 domain_color,
            float iso_color_offset, float iso_color_scale, float4 INTexCoord)
{

  //shade
  const float3 phit = orig + (dir*thit);

  STUB__EVAL_GRADIENT
	//const float3 gradient = evaluate_gradient(phit, w, r0, r1, r2);
  
  float3 normal;

  STUB__BUMPMAP

  // cube mapping hack
STUB__CUBEMAP_IFDEF
#if 1
  float3 reflected =  texCUBE(cube_map,reflect(dir, normal)).xyz;
  return reflected;
#else
  float dx = 0.25f;
  float dy = 0.25f;
  float dz = 0.25f;
  float3 reflected =  
  texCUBE(cube_map,reflect(float3(dir + float3(dx,dy,dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(-dx,dy,dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(dx,-dy,dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(-dx,-dy,dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(dx,dy,-dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(-dx,dy,-dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(dx,-dy,-dz)), normal)).xyz +
  texCUBE(cube_map,reflect(float3(dir + float3(-dx,-dy,-dz)), normal)).xyz;    
  return reflected * 0.125f;
#endif
#endif

  float3 light_direction = normalize(light_pos - phit);

  float3 v = -ray_dir;
  float n_dot_v = dot(normal, v);
  if(n_dot_v < 0)
    normal = -normal;

  float n_dot_l = dot(normal, light_direction);


  STUB__SHADE

  //float3 lookup_color = n_dot_v > 0 ? front_color : back_color ;
  //float3 lookup_color = n_dot_v > 0 ? INTexCoord : 1 -INTexCoord ;
  //float3 lookup_color = lerp( front_color, back_color, saturate(log(length(gradient))));

  //isoline code
  //if (frac(length(gradient)) < .1)
  //{
  //	lookup_color = float3(1,0,0);	
    //specular = 0;
  //}
  
  //  lookup_color = (phit - domain_min) / domain_diag;
      
  float specular = 0;

  //ambient;
  float3 color = .15 * lookup_color;
  
  if (n_dot_l > 0)
  {
  
STUB__SHADOWS_IFDEF
    //shadows

    float3 shadow_org, shadow_dir;
    {
      float3 shadow_ray_dir = light_pos - phit;
      const float3 shadow_domain_t0 = (domain_min - phit) / shadow_ray_dir;
      const float3 shadow_domain_t1 = (domain_max - phit) / shadow_ray_dir;
      const float3 shadow_tmax = max(shadow_domain_t0, shadow_domain_t1);   
      const float shadow_texit = min(shadow_tmax.x, min(shadow_tmax.y, shadow_tmax.z));
      const float3 shadow_pexit = phit + (shadow_texit * shadow_ray_dir);

      const float shadow_eps = shadow_eps_factor*max(pow(.5, max_depth), epsilon);
      shadow_org = shadow_pexit + (shadow_ray_dir*shadow_eps);
      shadow_dir = (phit - shadow_pexit) * (1-shadow_eps);
    }

    hitrecord shadow_hr = traverse(shadow_org, shadow_dir, w, r0, r1, r2, isovalue, iso_incr, inf, nan, max_depth, epsilon, delta);

    if (shadow_hr.thit.x < 0)      
#endif      
    {
      //diffuse
      const float diffuse = clamp( n_dot_l,0,1);
      color += diffuse * lookup_color;

      //phong specular
      const float3 half_vector = normalize(v + light_direction);
      const float n_dot_h = max( dot(normal, half_vector),0);
      color += phong_exponent >= 0 ? pow( n_dot_h, phong_exponent ) : 0;
    }
  }
  
  //color *= (.5*perlin3d(phit) + .5);
  //color *= clamp(.5 * turbulence(4, phit, 1, 2) + .5, 0, 1);

  return color;
}
#endif


// Raycasting fragment program implementation
// Arbitrary implicit using interval bisection
fragment_out fragment_main( vertex_fragment IN,
                            uniform float4 origin,             //alex: eye point
                            uniform float3 camera_u,           //alex: (0,0,0) at the moment
                            uniform float3 camera_v,           //alex: (0,0,0) at the moment
                            uniform float3 camera_w,           //alex: (0,0,0) at the moment
                            uniform float2 half_pixel_uv,	
                            uniform float nan,                 //alex: contains only nan value
                            uniform float inf,                 //alex: contains only inf value
                            uniform float wt,// FIXME
                            uniform float r0,                  //alex: 1?????
                            uniform float r1,                  //alex: 1?????
                            uniform float r2,                  //alex: 1?????
                            uniform float4 isovalue,           //alex: (0,0,0,0) at the moment
                            uniform float iso_incr,            //alex: 1 at the moment
                            uniform float max_depth,           //alex: 10 at the moment
                            uniform float epsilon,             //alex: .001 at the moment
                            uniform float delta,               //alex: 0 at the moment
                            uniform float shadow_eps_factor,
                            uniform float dp_alpha,
                            uniform float bumpmap_frequency,
                            uniform float phong_exponent,
                            uniform float3 domain_min,         //alex: min corner of box
                            uniform float3 domain_max,         //alex: max corner of box
                            uniform float3 light_pos,
                            uniform float3 front_color,
                            uniform float3 back_color, 
                            uniform float3 domain_color,
                            uniform float iso_color_offset,
                            uniform float iso_color_scale )
{
    
#if PTS
    int n=0;
    for(int i=0; i<4; i++)
        for(int j=0; j<4; j++)
            for(int k=0; k<4; k++)
            {
                pts[i][j][k] = tex1D(permutations_x_tex, ((float)n)/256).x;
                n++;
            }  
#endif
    
    
    fragment_out OUT;
    
    
    //render the box for debuging
//  OUT.Color.xyz = float3(1,1,0);
//  OUT.Color.w = 1;
//  return OUT;
    const float3 domain_diag = domain_min - domain_max;
    float3 penter;//scaling does not change penter
    penter = domain_max + IN.TexCoord.xyz * domain_diag;	//note IN.TexCoord is always in [0,1]

//     const float3 domain_diag = domain_max - domain_min;
//     float3 penter = domain_min + IN.TexCoord.xyz * domain_diag;//	note IN.TexCoord is always in [0,1]
    //alex: division by zero? because of orthogonal projection
//     float3 eyeorigin = origin.xyz/origin.w - IN.GlyphPosition.xyz; // FIXME Hack that does not work for orthographic

    float3 my_origin = normalize(origin);
    my_origin*=5000;
    //scaling changes origin
    //scaling changes does not change IN.GlyphPosition.xyz
    //scaling changes eyeorigin
    float3 my_eyeorigin;
    my_eyeorigin = my_origin.xyz - IN.GlyphPosition.xyz;
    float3 eyeorigin;
    eyeorigin = origin.xyz - IN.GlyphPosition.xyz;
  
    
    glyphId = IN.GlyphPosition.w;
  
    float w = IN.GlyphPosition.w;
  
    lookupData( w );
  
    //this works too.
    //float2 pos = (IN.ScreenPos.xy / IN.ScreenPos.w) + half_pixel_uv;
    //float3 ray_dir = normalize(camera_w + (camera_u * pos.x) + (camera_v * pos.y));
  
    //scaling changes ray_dir
    float3 ray_dir = normalize(penter - my_eyeorigin);
    float3 inv_ray_dir = float3(1,1,1)/ray_dir;
  
    STUB__PRE_TRAVERSE
        
    float3 domain_t0 = (domain_max - my_eyeorigin) * inv_ray_dir;
    float3 domain_t1 = (domain_min - my_eyeorigin) * inv_ray_dir;
    
    float3 tmin = min(domain_t0, domain_t1);
    float3 tmax = max(domain_t0, domain_t1);
    //float tenter = max(tmin.x, max(tmin.y, tmin.z));
    float texit = min(tmax.x, min(tmax.y, tmax.z));
  
    float3 orig = penter;
    float3 dir = (my_eyeorigin + ray_dir * texit) - penter; // added the offset to reduce seams between the skybox and the bbox of the implicit
  
    //look up the *exit* position from back-buffer 2D texture
    //float2 texc = ((IN.ScreenPos.xy / IN.ScreenPos.w) + 1) / 2;		//convert from [-1,1] screen space to [0,1] texture space
    //float4 back_position  = tex2D(tex, texc);		//look up the back buffer texture at this texture coordinate
    //float3 dir = domain_min + (back_position.xyz * domain_diag) - orig;
    
    hitrecord hr = traverse(orig, dir, w, r0, r1, r2, isovalue, iso_incr, inf, nan, max_depth, epsilon, delta);
    //clip(hr.thit.x+2); //mario
 STUB__CUBEMAP_IFDEF  
        //no hits, we kill the fragment then
        if (all(hr.thit < 0))
        {
            //discard;
            //OUT.Color.xyz = texCUBE(cube_map,dir).xyz;
            //OUT.Color.w = 1;
            return OUT;
        }
#else   
 if (all(hr.thit < 0) )
    {
        //if we get an orange cube have done something wrong, as we got no hits

        // discard; //Mario: this has been commented out before //alex: i have to uncomment it in the end
//   alex      OUT.Color.xyz = tex2D( mydata, float2( 1./4./2. + 3./4., float(glyphId))).xyz; //float3(0.6, 0.8, 1.0); //domain_color;
       
        OUT.Color.w = 1.;
        OUT.depth = .35;//alex

      //   if( (IN.TexCoord.x < 0.02 || IN.TexCoord.x >.98||IN.TexCoord.y < 0.02 || IN.TexCoord.y >.98)&&
//             (IN.TexCoord.y < 0.02 || IN.TexCoord.y >.98||IN.TexCoord.z < 0.02 || IN.TexCoord.z >.98)&&
//             (IN.TexCoord.z < 0.02 || IN.TexCoord.z >.98||IN.TexCoord.x < 0.02 || IN.TexCoord.x >.98)               
//             )
//         {
//             OUT.Color.xyz = IN.TexCoord.xyz;
//             return OUT;
//         }
//         else
            discard;
    }      
#endif

    OUT.depth = .5; // FIXME (state.ModelViewMatrix * float4(phit, 1.)).z;

    float opacity = 0;
    float3 color = 0;
    float3 color0, color1, color2, color3;
  
    color0.xyz = shade(hr.thit.x, hr.opt.x, domain_min, domain_max, orig, dir, ray_dir, 
                       inf, nan, w, r0, r1, r2, isovalue, iso_incr,  
                       bumpmap_frequency, shadow_eps_factor, max_depth, epsilon, delta, dp_alpha, 
                       phong_exponent, light_pos, front_color, back_color, domain_color, 
                       iso_color_offset, iso_color_scale, IN.TexCoord);

    color += color0 * (1-opacity);

    STUB__DP_IFDEF
        opacity += dp_alpha * (1-opacity);
                      
    color = color0;
                     
    if (hr.thit.y >= 0)
    {
        color1 = shade(hr.thit.y, hr.opt.y, domain_min, domain_max, orig, dir, ray_dir, 
                       inf, nan, w, r0, r1, r2, isovalue, iso_incr, 
                       bumpmap_frequency, shadow_eps_factor, max_depth, epsilon, delta, dp_alpha, 
                       phong_exponent, light_pos, front_color, back_color, domain_color, 
                       iso_color_offset, iso_color_scale, IN.TexCoord);

        color += color1 * (1-opacity);
        opacity += dp_alpha * (1-opacity);

        if (hr.thit.z >= 0)
        {
            color2 = shade(hr.thit.z, hr.opt.z, domain_min, domain_max, orig, dir, ray_dir, 
                           inf, nan, w, r0, r1, r2, isovalue, iso_incr, 
                           bumpmap_frequency, shadow_eps_factor, max_depth, epsilon, delta, dp_alpha,  
                           phong_exponent, light_pos, front_color, back_color, domain_color,
                           iso_color_offset, iso_color_scale, IN.TexCoord);
                    
            color += color2 * (1-opacity);
            opacity += dp_alpha * (1-opacity);

            if (hr.thit.w >= 0)
            {
                color3 = shade(hr.thit.w, hr.opt.w, domain_min, domain_max, orig, dir, ray_dir, 
                               inf, nan, w, r0, r1, r2, isovalue, iso_incr, 
                               bumpmap_frequency, shadow_eps_factor, max_depth, epsilon, delta, dp_alpha,  
                               phong_exponent, light_pos, front_color, back_color, domain_color, 
                               iso_color_offset, iso_color_scale, IN.TexCoord);
      
                color += color3 * (1-opacity);
                opacity += dp_alpha * (1-opacity);
            }
        }
    }
  
    color += domain_color * (1-opacity);
#endif
    
    OUT.Color.xyz = color;
    OUT.Color.w = 1.;
    return OUT;
}
  

