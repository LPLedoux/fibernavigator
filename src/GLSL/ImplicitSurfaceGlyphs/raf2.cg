//Copyright (c) 2008 Aaron Knoll, Younis Hijazi, Andrew Kensler, Mathias Schott, Charles Hansen and Hans Hagen
//
// edited 2009 by Mario Hlawitschka and Alexander Wiebel
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.
#include "utils/GLSLShaderCode/FgeImplicitSurfaceGlyphs/iarith.cg"

//reduced affine form
struct raf
{
  float4 x1;
  float4 x2;
};

//x1.x = central value;
//x5.y = (n+1 from AF2)
//x6.z = (n+2 from AF2)
//x7.w = (n+3 from AF2)

//x2.x = x1 (shared symbol)
//x2.y = x2 (shared symbol)
//x2.z = x3 (shared symbol)
//x2.w = x4 (shared symbol)

raf make_raf(float lo, float hi)
{
  raf r;
  r.x1.x = (hi + lo) * .5;
  r.x2.x = (hi - lo) * .5;
  r.x1.yzw = 0;
  r.x2.yzw = 0;
  return r;
}

raf interval_to_raf(interval i)
{
  raf r;
  r.x1.x = (i.x + i.y) * .5;
  r.x2.x = (i.x - i.y) * .5;
  r.x1.yzw = 0;
  r.x2.yzw = 0;
  return r;
}

float raf_radius(raf r)
{
  float4 ae1 = abs(r.x1);
  ae1.zw *= .5; //these are only on [0,1] and [-1,0], not [-1,1]
  const float4 ae2 = abs(r.x2);
  return ae2.x + ae2.y + ae2.z + ae2.w + ae1.y + ae1.z + ae1.w;
}

interval raf_to_interval(raf r)
{
  const float rad = raf_radius(r);
  return interval(r.x1.x - rad, r.x1.x + rad);
}

bool raf_contains(raf r, float f)
{
  const float rad = raf_radius(r);
  return (f >= (r.x1.x - rad) && f <= (r.x1.x + rad));
}

raf raf_min(float a, raf b)
{
  if (a < b.x) return a;
  else return b;
}

raf raf_min(raf a, raf b)
{
  if (a.x < b.x) return a;
  else return b;
}

raf raf_max(float a, raf b)
{
 if (a < b.y) return b;
  else return a;
}

raf raf_max(raf a, raf b)
{
  if (a.y < b.y) return b;
  else return a;
}

raf raf_add(raf a, float b)
{
  raf r;
  r.x1 = a.x1;
  r.x1.x += b;
  r.x2 = a.x2;
  return r;
}

raf raf_add(float a, raf b)
{
  raf r;
  r.x1 = b.x1;
  r.x1.x += a;
  r.x2 = b.x2;
  return r;
}

raf raf_add(raf a, raf b)
{
  raf r;
  r.x1 = a.x1 + b.x1;
  r.x2 = a.x2 + b.x2;
  return r;
}

raf raf_sub(raf a, float b)
{
  raf r;
  r.x1 = a.x1;
  r.x1.x -= b;
  r.x2 = a.x2;
  return r;
}

raf raf_sub(float a, raf b)
{
  raf r;
  r.x1.x = a - b.x1.x;
  r.x1.yzw = b.x1.yzw;
  r.x2 = -b.x2;
  return r;
}

raf raf_sub(raf a, raf b)
{
  raf r;
  r.x1.x = a.x1.x - b.x1.x;
  r.x1.yzw = a.x1.yzw - b.x1.ywz;
  r.x2 = a.x2 - b.x2;
  return r;
}

//AARONBAD - won't work with AF2
raf raf_abs(raf r)
{
  interval i = raf_to_interval(r);
  
  if (i.x > 0) //strictly positive
    return r;
    
  if (i.y < 0)  //strictly negative
    return raf_neg(r);

  raf t = raf_mul(r,.5);
  t.x1.x = abs(t.x1.x);
  return t;
}

raf raf_neg(raf a)
{
  raf r;
  r.x1.x = -b.x1.x;
  r.x1.yzw = b.x1.yzw;
  r.x2 = -b.x2;
  return r;
}

//AARONBAD - won't work with AF2
raf raf_rcp(float inf, raf a)
{
  interval i = raf_to_interval(a);
  const bool ic0 = (i.x <= 0 && i.y >= 0);
  
  raf r;
  if (ic0)
  {
    r.x1.y = inf;
    return r;
  }
  
  const float2 iabs = abs(i);
  const float2 sia = sqrt(iabs);
  
  const float t = sia.x + sia.y;
  const float alpha = 1/t;
  const float dzeta = (t*.125) + (.5*sia.x*sia.y*alpha);
  
  const float rdelta = sia.y - sia.x;
  const float delta = rdelta*rdelta*.125*alpha;
  
  //make the affine form
  r = raf_mul(a, alpha);
  r.x1.x += dzeta;
  
  //condense error term delta into w
  r.x1.z = abs(r.x1.z) + delta;   //note delta is always positive
  r.x2 = 0;
  
  return r;
}

raf raf_mul(raf a, float b)
{
  raf r;
  r.x1.x = a.x1.x * b;
  r.x1.yzw = a.x1.yzw * abs(b);
  r.x2 = a.x2 * b;
  return r;
}

raf raf_mul(float a, raf b)
{
  raf r;
  r.x1.x = b.x1.x * a;
  r.x1.yzw = b.x1.yzw * abs(a);
  r.x2 = b.x2 * a;
  return r;
}

raf raf_mul(raf a, raf b)
{
  raf r;
  r.x1.x = a.x1.x * b.x1.x;
  r.x2 = a.x1.xxxx * b.x2.xyzw + b.x1.xxxx * a.x2.xyzw;

  float k1, k2, k3;
  {
    const float abs_a = a.x1.x;
    const float abs_b = b.x1.x;
    bool agt0 = a.x1.x > 0;
    bool bgt0 = b.x1.x > 0;

    k1 = abs_a * b.x1.y + abs_b * a.x1.y;  
    {
      const float k2_t1 = abs_a * (agt0 ? b.x1.z : b.x1.w);
      const float k2_t2 = abs_b * (bgt0 ? a.x1.z : a.x1.w);
      k2 = k2_t1 + k2_t2;
    }
    float k3;
    {
      const float k3_t1 = abs_a * (agt0 ? b.x1.w : b.x1.z);
      const float k3_t2 = abs_b * (bgt0 ? a.x1.w : a.x1.z);
      k3 = k3_t1 + k3_t2;
    }
  }

  {
    const float4 aax1 = abs(a.x1);
    const float4 aax2 = abs(a.x2);
    const float4 abx1 = abs(b.x1);
    const float4 abx2 = abs(b.x2);
 
    float4 tmp;
    tmp = aax2.xxxx * abx2.xyzw;
    k1 += tmp.y + tmp.z + tmp.w;
    tmp = aax2.xxxx * abx1.xyzw;
    k1 += tmp.y + tmp.z + tmp.w;
    tmp = aax2.yyyy * abx2.xyzw;
    k1 += tmp.x + tmp.z + tmp.w;
    tmp = aax2.yyyy * abx1.xyzw;
    k1 += tmp.y + tmp.z + tmp.w;
    tmp = aax2.zzzz * abx2.xyzw;
    k1 += tmp.x + tmp.y + tmp.w;
    tmp = aax2.zzzz * abx1.xyzw;
    k1 += tmp.y + tmp.z + tmp.w;
    tmp = aax2.wwww * abx2.xyzw;
    k1 += tmp.x + tmp.y + tmp.z;
    tmp = aax2.wwww * abx1.xyzw;
    k1 += tmp.y + tmp.z + tmp.w;
    tmp = aax1.yyyy * abx2.xyzw;
    k1 += tmp.x + tmp.y + tmp.z + tmp.w;
    tmp = aax1.yyyy * abx1.xyzw;
    k1 += tmp.z + tmp.w;
    tmp = aax1.zzzz * abx2.xyzw;
    k1 += tmp.x + tmp.y + tmp.z + tmp.w;
    tmp = aax1.zzzz * abx1.xyzw;
    k1 += tmp.y + tmp.w;    
    tmp = aax1.wwww * abx2.xyzw;
    k1 += tmp.x + tmp.y + tmp.z + tmp.w;
    tmp = aax1.wwww * abx1.xyzw;
    k1 += tmp.y + tmp.z;
  }
   
  {
    const float4 abx1 = a.x1.xyzw * b.x1.xyzw;
    const float4 abx2 = a.x2.xyzw * b.x2.xyzw;
    const bool4 abx1_gt0 = abx1 > 0;
    const bool4 abx2_gt0 = abx1 > 0;
    
    k2 += abx2_gt0.x ? abx2.x : 0;
    k3 += abx2_gt0.x ? 0 : abx2.x;
    k2 += abx2_gt0.y ? abx2.y : 0;
    k3 += abx2_gt0.y ? 0 : abx2.y;
    k2 += abx2_gt0.z ? abx2.z : 0;
    k3 += abx2_gt0.z ? 0 : abx2.z;
    k2 += abx2_gt0.w ? abx2.w : 0;
    k3 += abx2_gt0.w ? 0 : abx2.w;

    k2 += abx1_gt0.y ? abx1.y : 0;
    k3 += abx1_gt0.y ? 0 : abx1.y;
    k2 += abx1_gt0.z ? abx1.z : 0;
    k3 += abx1_gt0.z ? 0 : abx1.z;
    k2 += abx1_gt0.w ? abx1.w : 0;
    k3 += abx1_gt0.w ? 0 : abx1.w;
  }
  
  r.x1.y = k1;
  r.x1.z = k2;
  r.x1.w = k3;
  
  return r;
}

raf raf_div(float inf, raf a, float b)
{
  return raf_mul(a, 1/b);
}

raf raf_div(float inf, float a, raf b)
{
  return raf_mul(a, raf_rcp(inf, b));
}

raf raf_div(float inf, raf a, raf b)
{
  return raf_mul(a, raf_rcp(inf, b));
}

raf raf_sqr(raf a)
{
  return raf_mul(a,a);  //is this any good? This is what libaffa does...
}


/*
//AARONBAD - TODO

interval iexp(interval i)
{
	return exp(i);
}

interval ilog(float nan, float inf, interval i)
{
	interval r;
	r.x = i.x < 0 ? -inf : log(i.x);
	r.y = log(i.y);
	r.x = i.y < 0 ? nan : r.x;
	r.y = i.y < 0 ? nan : r.y;
	return r;
}

interval iln(float nan, float inf, interval i)
{
	return ilog(nan, inf, i);
}

interval ipow(float nan, float inf, interval i, float p)
{
	return iexp(imul(p, ilog(nan, inf, i)));
}

interval ipow(float nan, float inf, interval i, interval p)
{
	return iexp(imul(p, ilog(nan, inf, i)));
}

interval isqrt(float nan, float inf, interval i)
{
	return ipow(nan, inf, i, .5);
}

interval icos(interval i)
{
	float divtest = abs(i.x) / (2*PI);
	float ip = divtest - frac(divtest);
	interval imv = i + (i.x < 0 ? 2*PI*(ip+1) : -2*PI*ip);
	interval cosine = cos(imv);
    interval result;
	result.x = min(cosine.x, cosine.y);
	result.y = max(cosine.x, cosine.y);
	result.x = (icontains(imv, PI) || imv.y >= 3*PI) ? -1 : result.x;
	result.y = (imv.y >= 2*PI) ? 1 : result.y;
	return result;
}

interval isin(interval i)
{
	return icos(isub(i,.5*PI));
}

interval itan(float inf, interval i)
{
	return idiv(inf, isin(i), icos(i));
}

*/
