Index: splineSurf.vs
===================================================================
--- splineSurf.vs	(revision 331)
+++ splineSurf.vs	(working copy)
@@ -13,9 +13,9 @@
 
 		for (int j = 0; j < 6; ++j) {
 			vec3 v = gl_Vertex.xyz;
-			v.x = (v.x) / (float) dimX;
-			v.y = (v.y) / (float) dimY;
-			v.z = (v.z) / (float) dimZ;
+			v.x = (v.x) / float( dimX);
+			v.y = (v.y) / float( dimY);
+			v.z = (v.z) / float( dimZ);
 
 			for (int i = 9; i > -1; i--) {
 				if (type[i] == 1) {
@@ -24,10 +24,12 @@
 			}
 			vec3 offset = (greyVal - 0.5) * gl_Normal;
 
-			gl_Vertex.xyz += 2 * offset;
+			// FIXME: we cannot modify gl_Vertex, so we need to copy it!
+			// but if we copy it, we cannot use ftransform, so we have to fix the code below!
+			//gl_Vertex.xyz += 2 * offset;
 		}
 	}
 
-	gl_TexCoord[0].xyz = gl_Vertex;
+	gl_TexCoord[0].xyz = gl_Vertex.xyz;
 	gl_Position = ftransform();
 }
Index: fibers.fs
===================================================================
--- fibers.fs	(revision 331)
+++ fibers.fs	(working copy)
@@ -9,9 +9,9 @@
 
 void lookupTex() {
 	vec3 v = gl_TexCoord[0].xyz;
-	v.x = (v.x) / (float) dimX;
-	v.y = (v.y) / (float) dimY;
-	v.z = (v.z) / (float) dimZ;
+	v.x = (v.x) / float( dimX);
+	v.y = (v.y) / float( dimY);
+	v.z = (v.z) / float( dimZ);
 
 	vec3 col1;
 	col1.r = clamp(texture3D(tex, v).r, 0.0, 1.0);
@@ -32,7 +32,7 @@
 	 // be modified by a fragment shader. So a new variable
 	 // needs to be created. */
 
-	vec3 n = normal;
+	vec3 n = normal.xyz;
 
 	vec4 ambient = vec4(0.0);
 	vec4 diffuse = vec4(0.0);
@@ -42,7 +42,7 @@
 	 // to denote the number of lights. A better option may be passing
 	 // in the number of lights as a uniform or replacing the current
 	 // value with a smaller value. */
-	calculateLighting(gl_MaxLights, -n, vertex, gl_FrontMaterial.shininess,
+	calculateLighting(gl_MaxLights, -n, vertex.xyz, gl_FrontMaterial.shininess,
 			ambient, diffuse, specular);
 
 	 color = gl_Color + (ambient  * gl_FrontMaterial.ambient)
Index: transform.fs
===================================================================
--- transform.fs	(revision 331)
+++ transform.fs	(working copy)
@@ -44,9 +44,9 @@
 	vec4 color = vec4(0.0);
 
 	vec3 v = TexCoord;
-	v.x = (v.x) / (float) dimX;
-	v.y = (v.y) / (float) dimY;
-	v.z = (v.z) / (float) dimZ;
+	v.x = (v.x) / float( dimX);
+	v.y = (v.y) / float( dimY);
+	v.z = (v.z) / float( dimZ);
 
 	for (int i = 9; i > -1; i--) {
 		lookupTex(color, type[i], texes[i], threshold[i], v);
Index: mesh.vs
===================================================================
--- mesh.vs	(revision 331)
+++ mesh.vs	(working copy)
@@ -3,6 +3,6 @@
 void main()
 {
 	prepareLight();
-	gl_TexCoord[0].xyz = gl_Vertex;
+	gl_TexCoord[0].xyz = gl_Vertex.xyz;
     gl_Position = ftransform();
 }
Index: lighting.vs
===================================================================
--- lighting.vs	(revision 331)
+++ lighting.vs	(working copy)
@@ -1,17 +1,17 @@
 varying vec3 normal;
 varying vec4 vertex;
-varying vec3 half;
+varying vec3 halfvec;
 
 void prepareLight()
 {
 	/* Calculate the normal */
-	normal = normalize(gl_NormalMatrix * gl_Normal);
+	normal = normalize(gl_NormalMatrix * gl_Normal).xyz;
 
 	/* Transform the vertex position to eye space */
 	vertex = vec4(gl_ModelViewMatrix * gl_Vertex);
 
 	vec3 L = normalize(gl_LightSource[0].position.xyz - vertex.xyz);
 
-	half = vec3(L + vec3(0.0, 0.0, 1.0));
+	halfvec = vec3(L + vec3(0.0, 0.0, 1.0));
 }
 
Index: splineSurf.fs
===================================================================
--- splineSurf.fs	(revision 331)
+++ splineSurf.fs	(working copy)
@@ -71,15 +71,15 @@
     // to denote the number of lights. A better option may be passing
     // in the number of lights as a uniform or replacing the current
     // value with a smaller value. */
-    calculateLighting(gl_MaxLights, -n, vertex, gl_FrontMaterial.shininess,
+    calculateLighting(gl_MaxLights, -n, vertex.xyz, gl_FrontMaterial.shininess,
                       ambient, diffuse, specular);
 
    vec4 color = vec4(0.0);
 
 	vec3 v = gl_TexCoord[0].xyz;
-	v.x = (v.x) / (float)dimX;
-	v.y = (v.y) / (float)dimY;
-	v.z = (v.z) / (float)dimZ;
+	v.x = (v.x) / float(dimX);
+	v.y = (v.y) / float(dimY);
+	v.z = (v.z) / float(dimZ);
 
 	for (int i = 9 ; i > -1 ; i--)
 	{
Index: fibers.vs
===================================================================
--- fibers.vs	(revision 331)
+++ fibers.vs	(working copy)
@@ -5,7 +5,7 @@
 	gl_FrontColor = gl_Color;
 	gl_BackColor = gl_Color;
 
-	gl_TexCoord[0].xyz = gl_Vertex;
+	gl_TexCoord[0].xyz = gl_Vertex.xyz;
 
 	prepareLight();
 
Index: transform.vs
===================================================================
--- transform.vs	(revision 331)
+++ transform.vs	(working copy)
@@ -46,9 +46,9 @@
 
 	for (int j = 0; j < 6; ++j) {
 		vec3 v = gl_Vertex.xyz;
-		v.x = (v.x) / (float) dimX;
-		v.y = (v.y) / (float) dimY;
-		v.z = (v.z) / (float) dimZ;
+		v.x = (v.x) / float( dimX);
+		v.y = (v.y) / float( dimY);
+		v.z = (v.z) / float( dimZ);
 
 		for (int i = 9; i > -1; i--) {
 			if (type[i] == 1) {
Index: mesh.fs
===================================================================
--- mesh.fs	(revision 331)
+++ mesh.fs	(working copy)
@@ -16,7 +16,8 @@
 uniform int type[10];
 uniform int countTextures;
 
-vec3 defaultColorMap(float value) {
+vec3 defaultColorMap(float value)
+{
 	value *= 5.0;
 	vec3 color;
 
@@ -37,7 +38,8 @@
 	return color;
 }
 
-void cutFrontSector() {
+void cutFrontSector()
+{
 	if (sector == 1 && vertex.x > cutX && vertex.y > cutY && vertex.z > cutZ)
 		discard;
 	if (sector == 2 && vertex.x > cutX && vertex.y > cutY && vertex.z < cutZ)
@@ -59,14 +61,13 @@
 void cutAtSplineSurface()
 {
 	vec3 u = gl_TexCoord[0].xyz;
-	/*u.x = (u.x + dimX / 2) / (float) dimX;*/
-	u.y = (u.y) / (float) dimY;
-	u.z = (u.z) / (float) dimZ;
+	u.y = u.y / float(dimY);
+	u.z = u.z / float(dimZ);
 
 	for (int i = 9; i > -1; i--) {
 		if (type[i] == 5)
 		{
-			if (vertex.x < (texture2D(cutTex, u.yz).r * dimX)) discard;
+			if (vertex.x < (texture2D(cutTex, u.yz).r * float(dimX))) discard;
 		}
 	}
 }
@@ -109,26 +110,25 @@
 	/* Normalize the normal. A varying variable CANNOT
 	 // be modified by a fragment shader. So a new variable
 	 // needs to be created. */
-	vec3 n = normal;
+	vec3 n = normal.xyz;
 
-	vec4 ambient = vec4(0.0);
-	vec4 diffuse = vec4(0.0);
-	vec4 specular = vec4(0.0);
+	vec4 ambient;/* = vec4(0.0);*/
+	vec4 diffuse;/* = vec4(0.0);*/
+	vec4 specular;/* = vec4(0.0);*/
 
 	/* In this case the built in uniform gl_MaxLights is used
 	 // to denote the number of lights. A better option may be passing
 	 // in the number of lights as a uniform or replacing the current
 	 // value with a smaller value. */
-	calculateLighting(gl_MaxLights, -n, vertex, gl_FrontMaterial.shininess,
-			ambient, diffuse, specular);
+	calculateLighting(gl_MaxLights, -n, vertex.xyz, gl_FrontMaterial.shininess, ambient, diffuse, specular);
 
 	vec4 color = vec4(0.0);
 
 	if (useTex) {
 		vec3 v = gl_TexCoord[0].xyz;
-		v.x = (v.x) / (float) dimX;
-		v.y = (v.y) / (float) dimY;
-		v.z = (v.z) / (float) dimZ;
+		v.x = v.x / float(dimX);
+		v.y = v.y / float(dimY);
+		v.z = v.z / float(dimZ);
 
 		for (int i = 9; i > -1; i--) {
 			if (show[i])
Index: lighting.fs
===================================================================
--- lighting.fs	(revision 331)
+++ lighting.fs	(working copy)
@@ -1,11 +1,11 @@
 varying vec3 normal;
 varying vec4 vertex;
-varying vec3 half;
+varying vec3 halfvec;
 
 const vec4 AMBIENT_BLACK = vec4(0.0, 0.0, 0.0, 1.0);
 const vec4 DEFAULT_BLACK = vec4(0.0, 0.0, 0.0, 0.0);
 
-bool isLightEnabled(in int i)
+bool isLightEnabled( in int i)
 {
     /* A separate variable is used to get
     // rid of a linker error.*/
@@ -22,24 +22,24 @@
     return(enabled);
 }
 
-float calculateAttenuation(in int i, in float dist)
+float calculateAttenuation( in int i, in float dist)
 {
-    return(1.0 / (gl_LightSource[i].constantAttenuation +
+    return( 1.0 / (gl_LightSource[i].constantAttenuation +
                   gl_LightSource[i].linearAttenuation * dist +
                   gl_LightSource[i].quadraticAttenuation * dist * dist));
 }
 
-void directionalLight(in int i, in vec3 normal, in float shininess,
+void directionalLight( in int i, in vec3 normal, in float shininess,
                       inout vec4 ambient, inout vec4 diffuse, inout vec4 specular)
 {
 	float nDotVP;
 	float nDotHV;
 	float pf;
 
-	vec3 L = normalize (gl_LightSource[i].position - vertex.xyz);
-	vec3 H = normalize (L + half.xyz);
+	vec3 L = normalize (gl_LightSource[i].position.xyz - vertex.xyz);
+	vec3 H = normalize (L + halfvec.xyz);
 
-	nDotVP = max(0.0, dot(normal, normalize(vec3(gl_LightSource[i].position))));
+	nDotVP = max(0.0, dot(normal, normalize((gl_LightSource[i].position.xyz))));
 	nDotHV = max(0.0, dot(normal, H));
 
 	if (nDotVP == 0.0)
